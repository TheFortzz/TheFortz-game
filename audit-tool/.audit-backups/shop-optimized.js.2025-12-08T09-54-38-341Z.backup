// Optimized Shop Rendering System

// Helper function to get the correct lobby canvas based on vehicle type
function getCurrentLobbyCanvas() {
    const vehicleType = window.currentLobbyVehicleType || (window.gameState && window.gameState.selectedVehicleType) || 'tank';
    
    if (vehicleType === 'jet') {
        return document.getElementById('jetLobbyBackground');
    } else if (vehicleType === 'race') {
        return document.getElementById('raceLobbyBackground');
    } else {
        return document.getElementById('tankLobbyBackground');
    }
}

const OptimizedShop = {
    // Cache for shop items
    itemCache: new Map(),
    
    // Render only when needed
    needsRedraw: true,
    
    // Offscreen canvas for shop
    offscreenCanvas: null,
    offscreenCtx: null,
    
    // Current scroll positions
    scrollPositions: {},
    
    // Visible items only
    visibleItems: [],
    
    // Animation frame ID
    animationId: null,
    
    // FPS limiter (30 FPS for shop is enough)
    lastRenderTime: 0,
    renderInterval: 1000 / 30, // 30 FPS
    
    init() {
        // Create offscreen canvas for caching
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCanvas.width = window.innerWidth;
        this.offscreenCanvas.height = window.innerHeight;
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
        
        // Initialize scroll positions
        this.scrollPositions = {
            blue: 0,
            camo: 0,
            desert: 0,
            purple: 0,
            red: 0
        };
        
        console.log('✓ Optimized shop initialized');
    },
    
    // Mark shop for redraw
    markDirty() {
        this.needsRedraw = true;
    },
    
    // Render shop items to offscreen canvas (only when needed)
    renderToCache() {
        if (!this.needsRedraw) return;
        
        const ctx = this.offscreenCtx;
        const canvas = this.offscreenCanvas;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Render shop background
        this.renderShopBackground(ctx, canvas);
        
        // Render visible items only
        this.renderVisibleItems(ctx, canvas);
        
        this.needsRedraw = false;
    },
    
    renderShopBackground(ctx, canvas) {
        // Dark overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Title
        ctx.save();
        ctx.font = 'bold 48px Arial';
        ctx.fillStyle = '#00f7ff';
        ctx.textAlign = 'center';
        ctx.fillText('SHOP', canvas.width / 2, 80);
        ctx.restore();
    },
    
    renderVisibleItems(ctx, canvas) {
        // Calculate visible area
        const startY = 150;
        const itemHeight = 300;
        const itemsPerRow = 4;
        const spacing = 20;
        
        // Only render items in viewport
        const colors = ['blue', 'camo', 'desert', 'purple', 'red'];
        let currentY = startY;
        
        colors.forEach(color => {
            this.renderColorRow(ctx, canvas, color, currentY, itemsPerRow, spacing);
            currentY += itemHeight + 40;
        });
    },
    
    renderColorRow(ctx, canvas, color, y, itemsPerRow, spacing) {
        // Color label
        ctx.save();
        ctx.font = 'bold 24px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        ctx.fillText(color.toUpperCase(), 50, y - 10);
        ctx.restore();
        
        // Get items for this color
        const items = this.getItemsForColor(color);
        const scrollOffset = this.scrollPositions[color] || 0;
        
        // Calculate visible items
        const startX = 50;
        const itemWidth = 250;
        const totalWidth = canvas.width - 100;
        
        items.forEach((item, index) => {
            const x = startX + (index * (itemWidth + spacing)) - scrollOffset;
            
            // Only render if visible
            if (x + itemWidth > 0 && x < canvas.width) {
                this.renderShopItem(ctx, item, x, y, itemWidth, 250);
            }
        });
    },
    
    renderShopItem(ctx, item, x, y, width, height) {
        // Use cached version if available
        const cacheKey = `${item.type}_${item.name}_${item.owned}`;
        
        if (this.itemCache.has(cacheKey)) {
            const cached = this.itemCache.get(cacheKey);
            ctx.drawImage(cached, x, y);
            return;
        }
        
        // Render to cache
        const itemCanvas = document.createElement('canvas');
        itemCanvas.width = width;
        itemCanvas.height = height;
        const itemCtx = itemCanvas.getContext('2d');
        
        // Background
        itemCtx.fillStyle = item.owned ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 255, 255, 0.1)';
        itemCtx.fillRect(0, 0, width, height);
        
        // Border
        itemCtx.strokeStyle = item.owned ? '#00ff00' : '#00f7ff';
        itemCtx.lineWidth = 3;
        itemCtx.strokeRect(0, 0, width, height);
        
        // Item preview (simplified)
        itemCtx.fillStyle = '#fff';
        itemCtx.font = 'bold 20px Arial';
        itemCtx.textAlign = 'center';
        itemCtx.fillText(item.name, width / 2, height - 40);
        
        // Price
        if (!item.owned) {
            itemCtx.fillStyle = '#FFD700';
            itemCtx.fillText(`${item.price} Fortz`, width / 2, height - 15);
        } else {
            itemCtx.fillStyle = '#00ff00';
            itemCtx.fillText('OWNED', width / 2, height - 15);
        }
        
        // Cache it
        this.itemCache.set(cacheKey, itemCanvas);
        
        // Draw to main canvas
        ctx.drawImage(itemCanvas, x, y);
    },
    
    getItemsForColor(color) {
        // Get items from game state
        const items = [];
        
        // Add bodies
        if (window.TANK_CONFIG && window.TANK_CONFIG.bodies) {
            window.TANK_CONFIG.bodies.forEach(body => {
                items.push({
                    type: 'body',
                    name: body,
                    color: color,
                    price: window.TANK_CONFIG.prices.bodies[body] || 100,
                    owned: window.gameState?.ownedItems?.bodies?.includes(body) || false
                });
            });
        }
        
        // Add weapons
        if (window.TANK_CONFIG && window.TANK_CONFIG.weapons) {
            window.TANK_CONFIG.weapons.forEach(weapon => {
                items.push({
                    type: 'weapon',
                    name: weapon,
                    color: color,
                    price: window.TANK_CONFIG.prices.weapons[weapon] || 300,
                    owned: window.gameState?.ownedItems?.weapons?.includes(weapon) || false
                });
            });
        }
        
        return items;
    },
    
    // Main render loop (throttled to 30 FPS)
    render(currentTime) {
        if (!window.gameState?.showShop) {
            this.stop();
            return;
        }
        
        // Throttle to 30 FPS
        if (currentTime - this.lastRenderTime < this.renderInterval) {
            this.animationId = requestAnimationFrame((time) => this.render(time));
            return;
        }
        
        this.lastRenderTime = currentTime;
        
        // Render to cache if needed
        this.renderToCache();
        
        // Draw cached version to main canvas
        const lobbyCanvas = getCurrentLobbyCanvas() || document.getElementById('tankLobbyBackground');
        if (lobbyCanvas) {
            const ctx = lobbyCanvas.getContext('2d');
            ctx.drawImage(this.offscreenCanvas, 0, 0);
        }
        
        this.animationId = requestAnimationFrame((time) => this.render(time));
    },
    
    start() {
        if (this.animationId) return; // Already running
        
        this.markDirty();
        this.animationId = requestAnimationFrame((time) => this.render(time));
        console.log('✓ Optimized shop rendering started');
    },
    
    stop() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
            console.log('✓ Optimized shop rendering stopped');
        }
    },
    
    // Handle scroll
    scroll(color, direction) {
        const scrollAmount = 270; // One item width
        this.scrollPositions[color] = (this.scrollPositions[color] || 0) + (direction * scrollAmount);
        
        // Clamp scroll
        this.scrollPositions[color] = Math.max(0, this.scrollPositions[color]);
        
        this.markDirty();
    },
    
    // Clear cache when items change
    clearCache() {
        this.itemCache.clear();
        this.markDirty();
    }
};

// Initialize on load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => OptimizedShop.init());
} else {
    OptimizedShop.init();
}

// Export
window.OptimizedShop = OptimizedShop;
