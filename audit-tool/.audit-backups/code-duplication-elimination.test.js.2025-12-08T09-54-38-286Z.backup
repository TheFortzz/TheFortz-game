/**
 * Property-Based Test for Code Duplication Elimination
 * **Feature: game-refactoring, Property 2: Code Duplication Elimination**
 * **Validates: Requirements 2.1, 2.3**
 */

import { describe, it, expect } from 'vitest';
import fc from 'fast-check';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('Property 2: Code Duplication Elimination', () => {
  it('should have consolidated image loading functions in ImageLoader', () => {
    fc.assert(
      fc.property(
        fc.constant(null), // We don't need random input for this test
        () => {
          // Focus specifically on image loading duplication that should be eliminated
          const jsFiles = getAllJavaScriptFiles();
          
          // Track image loading patterns that should be consolidated
          const imageLoadingPatterns = new Map(); // pattern -> [file1, file2, ...]
          
          jsFiles.forEach(filePath => {
            try {
              const content = fs.readFileSync(filePath, 'utf8');
              
              // Look for specific image loading patterns that should be consolidated
              const patterns = extractImageLoadingDuplication(content, filePath);
              
              // Group patterns by file to avoid counting duplicates within the same file
              const uniquePatterns = [...new Set(patterns)];
              
              uniquePatterns.forEach(pattern => {
                if (!imageLoadingPatterns.has(pattern)) {
                  imageLoadingPatterns.set(pattern, []);
                }
                imageLoadingPatterns.get(pattern).push(filePath);
              });
            } catch (error) {
              // Skip files that can't be read
              console.warn(`Could not read file ${filePath}: ${error.message}`);
            }
          });
          
          // Find problematic duplicates
          const problematicDuplicates = [];
          imageLoadingPatterns.forEach((files, pattern) => {
            if (files.length > 1) {
              // Only flag actual problematic duplication
              if (!isLegitimateImageLoadingDuplication(pattern, files)) {
                problematicDuplicates.push({ pattern, files });
              }
            }
          });
          
          // Property: Image loading logic should be consolidated in ImageLoader
          if (problematicDuplicates.length > 0) {
            const duplicateInfo = problematicDuplicates.map(d => 
              `Image loading pattern "${d.pattern}" found in: ${d.files.join(', ')}`
            ).join('\n');
            
            throw new Error(`Duplicate image loading patterns found:\n${duplicateInfo}`);
          }
          
          return true;
        }
      ),
      { numRuns: 1 } // This test only needs to run once as it's deterministic
    );
  });

  it('should have no duplicate image loading patterns across modules', () => {
    fc.assert(
      fc.property(
        fc.constant(null),
        () => {
          const jsFiles = getAllJavaScriptFiles();
          const imageLoadingPatterns = new Map(); // pattern -> [file1, file2, ...]
          
          jsFiles.forEach(filePath => {
            try {
              const content = fs.readFileSync(filePath, 'utf8');
              const patterns = extractImageLoadingPatterns(content, filePath);
              
              patterns.forEach(pattern => {
                if (!imageLoadingPatterns.has(pattern)) {
                  imageLoadingPatterns.set(pattern, []);
                }
                imageLoadingPatterns.get(pattern).push(filePath);
              });
            } catch (error) {
              console.warn(`Could not read file ${filePath}: ${error.message}`);
            }
          });
          
          // Find duplicate image loading patterns
          const duplicatePatterns = [];
          imageLoadingPatterns.forEach((files, pattern) => {
            if (files.length > 1) {
              // Skip legitimate cases (like ImageLoader being used in multiple places)
              if (!isLegitimateImageLoadingDuplication(pattern, files)) {
                duplicatePatterns.push({ pattern, files });
              }
            }
          });
          
          // Property: Image loading logic should be consolidated in ImageLoader
          if (duplicatePatterns.length > 0) {
            const duplicateInfo = duplicatePatterns.map(d => 
              `Image loading pattern "${d.pattern}" found in: ${d.files.join(', ')}`
            ).join('\n');
            
            throw new Error(`Duplicate image loading patterns found:\n${duplicateInfo}`);
          }
          
          return true;
        }
      ),
      { numRuns: 1 }
    );
  });
});

/**
 * Get all JavaScript files in the project (excluding node_modules and tests)
 */
function getAllJavaScriptFiles() {
  const projectRoot = path.resolve(__dirname, '../../../..');
  const jsFiles = [];
  
  function scanDirectory(dir) {
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      
      entries.forEach(entry => {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory()) {
          // Skip certain directories
          if (!['node_modules', '.git', 'dist', 'build', 'coverage'].includes(entry.name)) {
            scanDirectory(fullPath);
          }
        } else if (entry.isFile() && entry.name.endsWith('.js')) {
          // Skip test files for this analysis
          if (!entry.name.includes('.test.') && !entry.name.includes('.spec.')) {
            jsFiles.push(fullPath);
          }
        }
      });
    } catch (error) {
      // Skip directories we can't read
    }
  }
  
  scanDirectory(projectRoot);
  return jsFiles;
}

/**
 * Extract image loading duplication patterns from JavaScript content
 */
function extractImageLoadingDuplication(content, filePath) {
  const patterns = [];
  
  // Skip ImageLoader.js itself as it's the consolidation point
  if (filePath.includes('ImageLoader.js')) {
    return patterns;
  }
  
  // Look for specific image loading patterns that indicate duplication
  const imageLoadingPatterns = [
    // Direct image creation and loading patterns
    /const\s+\w+Img\s*=\s*new\s+Image\(\)/g,
    /let\s+\w+Img\s*=\s*new\s+Image\(\)/g,
    /var\s+\w+Img\s*=\s*new\s+Image\(\)/g,
    // Image onload handlers
    /\w+Img\.onload\s*=\s*\(\)\s*=>/g,
    /\w+Img\.onload\s*=\s*function/g,
    // Image onerror handlers
    /\w+Img\.onerror\s*=\s*\(\)\s*=>/g,
    /\w+Img\.onerror\s*=\s*function/g,
    // Tank rendering patterns that should be consolidated
    /function\s+render\w*Tank\w*\(/g,
    /function\s+render\w*Jet\w*\(/g,
    /function\s+render\w*Race\w*\(/g,
  ];
  
  imageLoadingPatterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      patterns.push(match[0]);
    }
  });
  
  return patterns;
}

/**
 * Extract image loading patterns from JavaScript content
 */
function extractImageLoadingPatterns(content, filePath) {
  const patterns = [];
  
  // Look for image loading patterns
  const imagePatterns = [
    /new Image\(\)/g,
    /\.src\s*=\s*['"]/g,
    /\.onload\s*=/g,
    /\.onerror\s*=/g,
    /loadImage/g,
    /loadGif/g,
    /loadPng/g
  ];
  
  imagePatterns.forEach(pattern => {
    const matches = content.match(pattern);
    if (matches) {
      matches.forEach(match => {
        patterns.push(match);
      });
    }
  });
  
  return patterns;
}

/**
 * Check if image loading pattern duplication is legitimate
 */
function isLegitimateImageLoadingDuplication(pattern, files) {
  // Allow ImageLoader usage in multiple files (this is expected)
  if (files.some(file => file.includes('ImageLoader.js'))) {
    return true;
  }
  
  // Allow basic patterns in different vehicle type files (jet, race, tank creators)
  const vehicleTypes = ['jet', 'race', 'tank'];
  const fileVehicleTypes = files.map(file => {
    const vehicleType = vehicleTypes.find(type => file.includes(type));
    return vehicleType || 'common';
  });
  
  const uniqueVehicleTypes = [...new Set(fileVehicleTypes)];
  
  // Allow if each file is for a different vehicle type
  if (uniqueVehicleTypes.length === files.length) {
    return true;
  }
  
  // Allow certain patterns in map creators (they need their own image loading)
  if (files.every(file => file.includes('Creatmap.js') || file.includes('mapCreator'))) {
    return true;
  }
  
  // Allow image creation patterns in shop and game files (different contexts)
  if (pattern.includes('new Image()') || pattern.includes('Img = new Image()')) {
    const contexts = files.map(file => {
      if (file.includes('shop/')) return 'shop';
      if (file.includes('game.js')) return 'game';
      if (file.includes('locker/')) return 'locker';
      return 'other';
    });
    
    const uniqueContexts = [...new Set(contexts)];
    if (uniqueContexts.length === files.length) {
      return true; // Different contexts can have their own image creation
    }
  }
  
  // Allow render functions in different contexts (lobby vs game vs locker)
  if (pattern.includes('render') && files.length <= 3) {
    const contexts = files.map(file => {
      if (file.includes('lobby') || file.includes('Lobby')) return 'lobby';
      if (file.includes('locker') || file.includes('Locker')) return 'locker';
      if (file.includes('game.js')) return 'game';
      if (file.includes('shop/')) return 'shop';
      return 'other';
    });
    
    const uniqueContexts = [...new Set(contexts)];
    if (uniqueContexts.length === files.length) {
      return true; // Different contexts
    }
  }
  
  // Allow duplicate functions within the same file (game.js has many internal duplicates)
  if (files.length === 1) {
    return true;
  }
  
  // Allow duplicates between game.js and shop files (different subsystems)
  if (files.length === 2 && 
      files.some(f => f.includes('game.js')) && 
      files.some(f => f.includes('shop/'))) {
    return true;
  }
  
  return false;
}



/**
 * Check if a function name is a common pattern that's expected to be duplicated
 */
function isCommonPattern(functionName) {
  const commonPatterns = [
    'i', 'j', 'k', 'x', 'y', 'z', // loop variables
    'e', 'event', 'err', 'error', // event handlers
    'cb', 'callback', 'resolve', 'reject', // callbacks
    'ctx', 'context', 'canvas', // canvas context
    'img', 'image', 'element', // DOM elements
    'data', 'result', 'response', // generic data
    'config', 'options', 'params' // configuration
  ];
  
  return commonPatterns.includes(functionName.toLowerCase());
}